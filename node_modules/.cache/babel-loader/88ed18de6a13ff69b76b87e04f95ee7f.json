{"ast":null,"code":"/**\n * Main breadth first search function.\n * \n * @param {*} startPoint starting point.\n * @param {*} endPoint ending point.\n * @param {*} grid whole grid.\n * @returns all visited points part of bfs in order.\n */\nexport const breadthFirstSearch = (startPoint, grid) => {\n  var pointsInOrder = [];\n  startPoint.setDistance(0);\n  const unvisited = getAllPoints(grid);\n\n  while (unvisited.length > 0) {\n    unvisited.sort((point1, point2) => point1.distance - point2.distance);\n    const closestPoint = unvisited.shift();\n    closestPoint.setVisited(true);\n    pointsInOrder.push(closestPoint);\n\n    if (closestPoint.isEnd) {\n      return pointsInOrder;\n    }\n\n    var neighbors = [];\n    const rowVal = closestPoint.x;\n    const colVal = closestPoint.y;\n\n    if (rowVal > 0) {\n      neighbors.push(grid[rowVal - 1][colVal]);\n    }\n\n    if (rowVal < grid.length - 1) {\n      neighbors.push(grid[rowVal + 1][colVal]);\n    }\n\n    if (colVal > 0) {\n      neighbors.push(grid[rowVal][colVal - 1]);\n    }\n\n    if (colVal < grid[rowVal].length - 1) {\n      neighbors.push(grid[rowVal][colVal + 1]);\n    }\n\n    neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n\n    for (let x = 0; x < neighbors.length; x++) {\n      neighbors[x].setDistance(closestPoint.distance + 1);\n      neighbors[x].setPrevious(closestPoint);\n    }\n  }\n\n  return pointsInOrder;\n};\n/**\n * Helper function to return all points in grid, as an array.\n * @param {*} grid whole grid. \n * @returns all points as an array.\n */\n\nconst getAllPoints = grid => {\n  const points = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      points.push(grid[i][j]);\n    }\n  }\n\n  return points;\n};\n/**\n * Returns shortest path in order between start and end points.\n * @param {*} endPoint end point.\n * @returns shortest path in order.\n */\n\n\nconst shortestPathInOrder = endPoint => {\n  const inOrderPath = [];\n  var curr = endPoint;\n\n  while (curr !== null) {\n    inOrderPath.unshift(curr);\n    curr = curr.previous;\n  }\n\n  return inOrderPath;\n};","map":{"version":3,"sources":["/Users/manavray/code/shortest-path-finder/src/algorithms/bfs.js"],"names":["breadthFirstSearch","startPoint","grid","pointsInOrder","setDistance","unvisited","getAllPoints","length","sort","point1","point2","distance","closestPoint","shift","setVisited","push","isEnd","neighbors","rowVal","x","colVal","y","filter","neighbor","isVisited","setPrevious","points","i","j","shortestPathInOrder","endPoint","inOrderPath","curr","unshift","previous"],"mappings":"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","sourcesContent":["\n/**\n * Main breadth first search function.\n * \n * @param {*} startPoint starting point.\n * @param {*} endPoint ending point.\n * @param {*} grid whole grid.\n * @returns all visited points part of bfs in order.\n */\nexport const breadthFirstSearch = (startPoint, grid) => {\n    var pointsInOrder = []\n    startPoint.setDistance(0);\n    const unvisited = getAllPoints(grid);\n\n    while(unvisited.length > 0) {\n        unvisited.sort((point1, point2) => point1.distance - point2.distance);\n        const closestPoint = unvisited.shift();\n\n        closestPoint.setVisited(true);\n        pointsInOrder.push(closestPoint);\n        if(closestPoint.isEnd) {\n            return pointsInOrder;\n        }        \n\n        var neighbors = [];\n        const rowVal = closestPoint.x;\n        const colVal = closestPoint.y;\n\n        if(rowVal > 0) {\n            neighbors.push(grid[rowVal - 1][colVal]);\n        }\n        if(rowVal < grid.length - 1) {\n            neighbors.push(grid[rowVal + 1][colVal])\n        }\n        if (colVal > 0) {\n            neighbors.push(grid[rowVal][colVal - 1]);\n        }\n        if(colVal < grid[rowVal].length - 1) {\n            neighbors.push(grid[rowVal][colVal + 1]);\n        }\n        \n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n\n        for(let x = 0; x < neighbors.length; x++) {\n            neighbors[x].setDistance(closestPoint.distance + 1);\n            neighbors[x].setPrevious(closestPoint);\n        }\n        \n    }\n\n    return pointsInOrder;\n}\n\n/**\n * Helper function to return all points in grid, as an array.\n * @param {*} grid whole grid. \n * @returns all points as an array.\n */\nconst getAllPoints = (grid) => {\n    const points = [];\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[i].length; j++) {\n            points.push(grid[i][j]);\n        }\n    }\n\n    return points;\n}\n\n/**\n * Returns shortest path in order between start and end points.\n * @param {*} endPoint end point.\n * @returns shortest path in order.\n */\nconst shortestPathInOrder = (endPoint) => {\n    const inOrderPath = [];\n    var curr = endPoint;\n    while (curr !== null) {\n        inOrderPath.unshift(curr);\n        curr = curr.previous;\n    }\n\n    return inOrderPath;\n}"]},"metadata":{},"sourceType":"module"}