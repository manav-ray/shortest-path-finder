{"ast":null,"code":"/**\n * Main breadth first search function.\n * \n * @param {*} startPoint starting point.\n * @param {*} endPoint ending point.\n * @param {*} grid whole grid.\n * @returns all visited points part of bfs in order.\n */\nexport const breadthFirstSearch = (startPoint, endPoint, grid) => {\n  // console.log(\"YEEEEE\");\n  var pointsInOrder = [];\n  startPoint.setDistance(0);\n  const unvisited = getAllPoints(grid);\n\n  while (unvisited.length > 0) {\n    unvisited.sort((point1, point2) => point1.distance - point2.distance);\n    const closestPoint = unvisited.shift();\n\n    if (closestPoint.distance === Infinity) {\n      return pointsInOrder;\n    }\n\n    if (!closestPoint.isVisited) {\n      closestPoint.setVisited(true);\n      pointsInOrder.push(closestPoint);\n\n      if (closestPoint.equals(endPoint)) {\n        return pointsInOrder;\n      }\n\n      var neighbors = [];\n      const rowVal = closestPoint.x;\n      const colVal = closestPoint.y;\n\n      if (rowVal > 0) {\n        neighbors.push(grid[rowVal - 1][colVal]);\n      }\n\n      if (rowVal < grid.length - 1) {\n        neighbors.push(grid[rowVal + 1][colVal]);\n      }\n\n      if (colVal > 0) {\n        neighbors.push(grid[rowVal][colVal - 1]);\n      }\n\n      if (colVal < grid.length[rowVal] - 1) {\n        neighbors.push(grid[rowVal[colVal + 1]]);\n      }\n\n      neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n\n      for (let x = 0; x < neighbors.length; x++) {\n        neighbors[x].setDistance(closestPoint.distance + 1);\n      }\n    }\n  }\n\n  return pointsInOrder;\n};\n/**\n * Helper function to return all points in grid, as an array.\n * @param {*} grid whole grid. \n * @returns all points as an array.\n */\n\nconst getAllPoints = grid => {\n  const points = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      points.push(grid[i][j]);\n    }\n  }\n\n  return points;\n};","map":{"version":3,"sources":["/Users/manavray/code/shortest-path-finder/src/algorithms/bfs.js"],"names":["breadthFirstSearch","startPoint","endPoint","grid","pointsInOrder","setDistance","unvisited","getAllPoints","length","sort","point1","point2","distance","closestPoint","shift","Infinity","isVisited","setVisited","push","equals","neighbors","rowVal","x","colVal","y","filter","neighbor","points","i","j"],"mappings":"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","sourcesContent":["\n/**\n * Main breadth first search function.\n * \n * @param {*} startPoint starting point.\n * @param {*} endPoint ending point.\n * @param {*} grid whole grid.\n * @returns all visited points part of bfs in order.\n */\nexport const breadthFirstSearch = (startPoint, endPoint, grid) => {\n    // console.log(\"YEEEEE\");\n    var pointsInOrder = []\n    startPoint.setDistance(0);\n    const unvisited = getAllPoints(grid);\n\n    while(unvisited.length > 0) {\n        unvisited.sort((point1, point2) => point1.distance - point2.distance);\n        const closestPoint = unvisited.shift();\n\n        if(closestPoint.distance === Infinity) {\n            return pointsInOrder;\n        }\n\n        if(!closestPoint.isVisited) {\n            closestPoint.setVisited(true);\n            pointsInOrder.push(closestPoint);\n            if(closestPoint.equals(endPoint)) {\n                return pointsInOrder;\n            }        \n\n            var neighbors = [];\n            const rowVal = closestPoint.x;\n            const colVal = closestPoint.y;\n\n            if(rowVal > 0) {\n                neighbors.push(grid[rowVal - 1][colVal]);\n            }\n            if(rowVal < grid.length - 1) {\n                neighbors.push(grid[rowVal + 1][colVal])\n            }\n            if (colVal > 0) {\n                neighbors.push(grid[rowVal][colVal - 1]);\n            }\n            if(colVal < grid.length[rowVal] - 1) {\n                neighbors.push(grid[rowVal[colVal + 1]]);\n            }\n            \n            neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n\n            for(let x = 0; x < neighbors.length; x++) {\n                neighbors[x].setDistance(closestPoint.distance + 1);\n            }\n        }\n    }\n\n    return pointsInOrder;\n}\n\n/**\n * Helper function to return all points in grid, as an array.\n * @param {*} grid whole grid. \n * @returns all points as an array.\n */\nconst getAllPoints = (grid) => {\n    const points = [];\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[i].length; j++) {\n            points.push(grid[i][j]);\n        }\n    }\n\n    return points;\n}"]},"metadata":{},"sourceType":"module"}