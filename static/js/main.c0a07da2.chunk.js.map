{"version":3,"sources":["Objects/Point.js","components/Node.js","algorithms/bfs.js","components/Grid.js","App.js","index.js"],"names":["Point","x","y","this","isStart","isEnd","distance","Infinity","isVisited","previous","isWall","setWall","boolean","setPrevious","point","setStart","setEnd","setDistance","newDistance","setVisited","equals","comparePoint","Node","numSpecials","setNumSpecials","useState","classes","setClasses","addWall","e","key","id","className","onClick","tempClass","onMouseOver","document","addEventListener","onMouseOut","removeEventListener","getAllPoints","grid","points","i","length","j","push","Grid","setGrid","show","setShow","handleClose","showIns","setShowIns","handleCloseIns","useEffect","width","window","innerWidth","height","innerHeight","console","log","initGrid","rows","cols","tempGrid","currRow","style","marginBottom","Button","marginRight","location","reload","getElementById","max","walls","Math","floor","random","k","setTimeout","currPoint","startPoint","endPoint","pointsInOrder","unvisited","sort","point1","point2","closestPoint","shift","neighbors","rowVal","colVal","filter","neighbor","breadthFirstSearch","shortestPath","inOrderPath","curr","unshift","shortestPathInOrder","map","row","rowId","col","colId","Modal","onHide","Header","closeButton","Body","Footer","variant","Title","App","ReactDOM","render","StrictMode"],"mappings":"yNAAaA,EAET,WAAYC,EAAGC,GAAI,IAAD,2BACdC,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,EACTC,KAAKC,SAAU,EACfD,KAAKE,OAAQ,EACbF,KAAKG,SAAWC,IAChBJ,KAAKK,WAAY,EACjBL,KAAKM,SAAW,KAChBN,KAAKO,QAAS,EAEdP,KAAKQ,QAAU,SAACC,GACZ,EAAKF,OAASE,GAGlBT,KAAKU,YAAc,SAACC,GAChB,EAAKL,SAAWK,GAGpBX,KAAKY,SAAW,SAACH,GACb,EAAKR,QAAUQ,GAGnBT,KAAKa,OAAS,SAACJ,GACX,EAAKP,MAAQO,GAGjBT,KAAKc,YAAc,SAACC,GAChB,EAAKZ,SAAWY,GAGpBf,KAAKgB,WAAa,SAACP,GACf,EAAKJ,UAAYI,GAGrBT,KAAKiB,OAAS,SAACC,GACX,OAAO,EAAKpB,IAAMoB,EAAapB,GAAK,EAAKC,IAAMmB,EAAanB,I,OClCzD,SAASoB,EAAT,GAAsD,IAAtCR,EAAqC,EAArCA,MAAOS,EAA8B,EAA9BA,YAAaC,EAAiB,EAAjBA,eAC/C,EAA8BC,mBAAS,IAAvC,mBAAOC,EAAP,KAAgBC,EAAhB,KA6BMC,EAAU,SAACC,GAGC,MAAVA,EAAEC,MACGhB,EAAMV,SAAYU,EAAMT,QACzBS,EAAMH,SAAQ,GACdgB,EAAW,gBAgBvB,OACI,qBAAKI,GAAE,eAAUjB,EAAMb,EAAhB,YAAqBa,EAAMZ,GAAK8B,UAAS,eAAUN,GAAWO,QA/CxD,WACb,GAAInB,EAAMV,SAAYU,EAAMT,MAMjBS,EAAMV,SACbU,EAAMC,UAAS,GACfD,EAAME,QAAO,IACNF,EAAMT,QACbmB,EAAeD,EAAc,GAC7BT,EAAMC,UAAS,GACfD,EAAME,QAAO,QAZkB,CAC/B,GAAoB,IAAhBO,EACA,OAEJC,EAAeD,EAAc,GAC7BT,EAAMC,UAAS,GAUnB,IAAImB,EACJA,EAAYpB,EAAMV,QAAU,aAAeU,EAAMT,MAAQ,WAAa,GACtEsB,EAAWO,IA6B6EC,YAT5E,WACZC,SAASC,iBAAiB,WAAYT,IAQwEU,WALjG,WACbF,SAASG,oBAAoB,WAAYX,M,oBCc3CY,EAAe,SAACC,GAElB,IADA,IAAMC,EAAS,GACPC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAC/BH,EAAOI,KAAKL,EAAKE,GAAGE,IAI5B,OAAOH,GCnEI,SAASK,IAEpB,MAAwBtB,mBAAS,IAAjC,mBAAOgB,EAAP,KAAaO,EAAb,KACA,EAAsCvB,mBAAS,GAA/C,mBAAOF,EAAP,KAAoBC,EAApB,KAEA,EAAwBC,oBAAS,GAAjC,mBAAOwB,EAAP,KAAaC,EAAb,KAEMC,EAAc,kBAAMD,GAAQ,IAIlC,EAA8BzB,oBAAS,GAAvC,mBAAO2B,EAAP,KAAgBC,EAAhB,KACMC,EAAiB,kBAAMD,GAAW,IAGxCE,qBAAU,WAFkBF,GAAW,GAKnC,IAAMG,EAAQC,OAAOC,WACfC,EAASF,OAAOG,YAEtBC,QAAQC,IAAIH,EAAQH,GAEpBO,EAASJ,EAAS,GAAIH,EAAQ,IAY9BC,OAAOpB,iBAAiB,UATxB,WACI,IAAMmB,EAAQC,OAAOC,WACfC,EAASF,OAAOG,YAEtBC,QAAQC,IAAIH,EAAQH,GAEpBO,EAASJ,EAAS,GAAIH,EAAQ,SAInC,IASH,IAAMO,EAAW,SAACC,EAAMC,GAGpB,IAFA,IAAMC,EAAW,GAETvB,EAAI,EAAGA,EAAIqB,EAAMrB,IAAK,CAE1B,IADA,IAAMwB,EAAU,GACRtB,EAAI,EAAGA,EAAIoB,EAAMpB,IACrBsB,EAAQrB,KAAK,IAAI9C,EAAM2C,EAAGE,IAG9BqB,EAASpB,KAAKqB,GAGlBnB,EAAQkB,IA0GZ,OACI,qCACI,sBAAKlC,UAAU,YAAf,UACA,oBAAIoC,MAAO,CAACC,aAAc,QAA1B,oCACI,cAACC,EAAA,EAAD,CAAQF,MAAO,CAACC,aAAc,OAAQE,YAAa,QAAStC,QAAS,kBAAMwB,OAAOe,SAASC,QAAO,IAAlG,mBACA,cAACH,EAAA,EAAD,CAAQF,MAAO,CAACC,aAAc,OAAQE,YAAa,QAAStC,QAxGnD,WACjB,IAAI,IAAIU,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAC3BJ,EAAKE,GAAGE,GAAGzC,SAAWqC,EAAKE,GAAGE,GAAGxC,OAGlCoC,EAAKE,GAAGE,GAAGnC,SACV+B,EAAKE,GAAGE,GAAGlC,SAAQ,GACnByB,SAASsC,eAAT,eAAgCjC,EAAKE,GAAGE,GAAG5C,EAA3C,YAAgDwC,EAAKE,GAAGE,GAAG3C,IAAK8B,UAAY,QAOxF,IAFA,IA+BkB2C,EA/BZC,EAAQ,GAENjC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAAK,CACpC,IAAIJ,EAAKE,GAAGE,GAAGzC,UAAWqC,EAAKE,GAAGE,GAAGxC,MAItB,KAuBLsE,EAxBmB,EAyB9BE,KAAKC,MAAMD,KAAKE,SAAWJ,MAvBtBlC,EAAKE,GAAGE,GAAGlC,SAAQ,GACnBiE,EAAM9B,KAAKL,EAAKE,GAAGE,KAK/B,IA5BuB,eA4BfmC,GACJC,YAAW,WACP,IAAMC,EAAYN,EAAMI,GACxB5C,SAASsC,eAAT,eAAgCQ,EAAUjF,EAA1C,YAA+CiF,EAAUhF,IAAK8B,UAAY,mBAC3E,EAAIgD,IAJHA,EAAI,EAAGA,EAAIJ,EAAMhC,OAAQoC,IAAM,EAA/BA,IA4EA,2BACA,cAACV,EAAA,EAAD,CAAQF,MAAO,CAACC,aAAc,OAAQE,YAAa,QAAStC,QArD5D,WAIR,IAHA,IAAIkD,EAAa,KACbC,EAAW,KAEPzC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAC3BJ,EAAKE,GAAGE,GAAGzC,QACX+E,EAAa1C,EAAKE,GAAGE,GAEjBJ,EAAKE,GAAGE,GAAGxC,QACf+E,EAAW3C,EAAKE,GAAGE,IAK/B,GAAkB,OAAfsC,GAAoC,OAAbC,EAO1B,IAFA,IAAMC,EDtIoB,SAACF,EAAYC,EAAU3C,GACrD,IAAI4C,EAAgB,GACpBF,EAAWlE,YAAY,GAGvB,IAFA,IAAMqE,EAAY9C,EAAaC,GAEzB6C,EAAU1C,OAAS,GAAG,CACxB0C,EAAUC,MAAK,SAACC,EAAQC,GAAT,OAAoBD,EAAOlF,SAAWmF,EAAOnF,YAC5D,IAAMoF,EAAeJ,EAAUK,QAE/B,IAAID,EAAahF,OAAjB,CAIA,GAAIgF,EAAapF,WAAaC,IAC1B,OAAO8E,EAKX,GAFAK,EAAavE,YAAW,GACxBkE,EAAcvC,KAAK4C,GAChBA,EAAatE,OAAOgE,GACnB,OAAOC,EAGX,IAAIO,EAAY,GACVC,EAASH,EAAazF,EACtB6F,EAASJ,EAAaxF,EAEzB2F,EAAS,GACRD,EAAU9C,KAAKL,EAAKoD,EAAS,GAAGC,IAEjCD,EAASpD,EAAKG,OAAS,GACtBgD,EAAU9C,KAAKL,EAAKoD,EAAS,GAAGC,IAEhCA,EAAS,GACTF,EAAU9C,KAAKL,EAAKoD,GAAQC,EAAS,IAEtCA,EAASrD,EAAKoD,GAAQjD,OAAS,GAC9BgD,EAAU9C,KAAKL,EAAKoD,GAAQC,EAAS,IAGzCF,EAAYA,EAAUG,QAAO,SAAAC,GAAQ,OAAKA,EAASxF,aAEnD,IAAI,IAAIP,EAAI,EAAGA,EAAI2F,EAAUhD,OAAQ3C,IACjC2F,EAAU3F,GAAGgB,YAAYyE,EAAapF,SAAW,GACjDsF,EAAU3F,GAAGY,YAAY6E,IAKjC,OAAOL,ECqFmBY,CAAmBd,EAAYC,EAAU3C,GApBjD,WAsBNuC,GACAA,IAAMK,EAAczC,OACpBqC,YAAW,WAEP,IADA,IAAMiB,EDlES,SAACd,GAGhC,IAFA,IAAMe,EAAc,GAChBC,EAAOhB,EACK,OAATgB,GACHD,EAAYE,QAAQD,GACpBA,EAAOA,EAAK3F,SAGhB,OAAO0F,EC0D8BG,CAAoBlB,GAD5B,WAELJ,GACJC,YAAW,WACP,IAAMC,EAAYgB,EAAalB,GAC1BE,EAAU9D,OAAO+D,IAAgBD,EAAU9D,OAAOgE,KACnDhD,SAASsC,eAAT,eAAgCQ,EAAUjF,EAA1C,YAA+CiF,EAAUhF,IAAK8B,UAAY,oBAE/E,GAAKgD,IANJA,EAAI,EAAGA,EAAIkB,EAAatD,OAAQoC,IAAM,EAAtCA,KAQT,EAAIA,GAGPC,YAAW,WACP,IAAMC,EAAYG,EAAcL,GAC3BE,EAAU9D,OAAO+D,IAAgBD,EAAU9D,OAAOgE,KACnDhD,SAASsC,eAAT,eAAgCQ,EAAUjF,EAA1C,YAA+CiF,EAAUhF,IAAK8B,UAAY,uBAE/E,EAAIgD,IApBPA,EAAI,EAAGA,GAAKK,EAAczC,OAAQoC,IAAM,EAAxCA,QAlIa9B,GAAQ,IAiKrB,qCAEJ,8BACKT,EAAK8D,KAAI,SAACC,EAAKC,GACZ,OACI,qBAAiBzE,UAAU,eAA3B,SACKwE,EAAID,KAAI,SAACG,EAAKC,GACX,OACI,cAACrF,EAAD,CAAkBR,MAAO2B,EAAKgE,GAAOE,GAAQpF,YAAaA,EAAaC,eAAgBA,GAA5EmF,OAHbF,QAWtB,eAACG,EAAA,EAAD,CAAO3D,KAAMA,EAAM4D,OAAQ1D,EAA3B,UACI,cAACyD,EAAA,EAAME,OAAP,CAAcC,aAAW,IAEzB,cAACH,EAAA,EAAMI,KAAP,wEACA,cAACJ,EAAA,EAAMK,OAAP,UACA,cAAC3C,EAAA,EAAD,CAAQ4C,QAAQ,YAAYjF,QAASkB,EAArC,wBAQJ,eAACyD,EAAA,EAAD,CAAO3D,KAAMG,EAASyD,OAAQvD,EAA9B,UACI,cAACsD,EAAA,EAAME,OAAP,CAAcC,aAAW,EAAzB,SACI,cAACH,EAAA,EAAMO,MAAP,6BAEJ,eAACP,EAAA,EAAMI,KAAP,WACI,sFACA,mIACA,wIACA,qEAEJ,cAACJ,EAAA,EAAMK,OAAP,UACA,cAAC3C,EAAA,EAAD,CAAQ4C,QAAQ,YAAYjF,QAASqB,EAArC,2BC/MD8D,MANf,WACE,OACE,cAACrE,EAAD,K,MCAJsE,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFnF,SAASsC,eAAe,W","file":"static/js/main.c0a07da2.chunk.js","sourcesContent":["export class Point {\n\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.isStart = false;\n        this.isEnd = false;\n        this.distance = Infinity;\n        this.isVisited = false;\n        this.previous = null;\n        this.isWall = false;\n\n        this.setWall = (boolean) => {\n            this.isWall = boolean;\n        }\n\n        this.setPrevious = (point) => {\n            this.previous = point;\n        }\n\n        this.setStart = (boolean) => {\n            this.isStart = boolean;\n        }\n\n        this.setEnd = (boolean) => {\n            this.isEnd = boolean;\n        }\n\n        this.setDistance = (newDistance) => {\n            this.distance = newDistance;\n        }\n\n        this.setVisited = (boolean) => {\n            this.isVisited = boolean;\n        }\n\n        this.equals = (comparePoint) => {\n            return this.x === comparePoint.x && this.y === comparePoint.y;\n        }\n    }\n\n    \n}","import React, {useState} from \"react\";\nimport \"./../main.css\"\n\nexport default function Node ({point, numSpecials, setNumSpecials}) {\n    const [classes, setClasses] = useState(\"\");\n\n    /**\n     * Sets the start and end points.\n     */\n    const setPoint = () => {\n        if(!point.isStart && !point.isEnd) {\n            if (numSpecials === 2) {\n                return;\n            }\n            setNumSpecials(numSpecials + 1);\n            point.setStart(true);\n        } else if (point.isStart) {\n            point.setStart(false);\n            point.setEnd(true);\n        } else if (point.isEnd) {\n            setNumSpecials(numSpecials - 1);\n            point.setStart(false);\n            point.setEnd(false);\n        }\n\n        var tempClass = \"\";\n        tempClass = point.isStart ? \"node-start\" : point.isEnd ? \"node-end\" : \"\";\n        setClasses(tempClass);\n    }\n\n    /**\n     * Adds a wall point to the grid.\n     */\n    const addWall = (e) => {\n        // console.log(e.key);\n\n        if (e.key === 'w') {\n            if (!point.isStart && !point.isEnd) {\n                point.setWall(true);\n                setClasses(\"node-wall\");\n            }\n        }\n    }\n\n    /**\n     * The two functions below are helper functions for adding walls.\n     */\n    const mouseIn = () => {\n        document.addEventListener(\"keypress\", addWall);\n    }\n\n    const mouseOut = () => {\n        document.removeEventListener(\"keypress\", addWall);\n    }\n\n    return (\n        <div id={`node-${point.x}-${point.y}`} className={`node ${classes}`} onClick={setPoint} onMouseOver={mouseIn} onMouseOut={mouseOut} />\n    )\n}","\n/**\n * Main breadth first search function.\n * \n * @param {*} startPoint starting point.\n * @param {*} endPoint ending point.\n * @param {*} grid whole grid.\n * @returns all visited points part of bfs in order.\n */\nexport const breadthFirstSearch = (startPoint, endPoint, grid) => {\n    var pointsInOrder = []\n    startPoint.setDistance(0);\n    const unvisited = getAllPoints(grid);\n\n    while(unvisited.length > 0) {\n        unvisited.sort((point1, point2) => point1.distance - point2.distance);\n        const closestPoint = unvisited.shift();\n\n        if (closestPoint.isWall) {\n            continue;\n        }\n\n        if (closestPoint.distance === Infinity) {\n            return pointsInOrder;\n        }\n\n        closestPoint.setVisited(true);\n        pointsInOrder.push(closestPoint);\n        if(closestPoint.equals(endPoint)) {\n            return pointsInOrder;\n        }        \n\n        var neighbors = [];\n        const rowVal = closestPoint.x;\n        const colVal = closestPoint.y;\n\n        if(rowVal > 0) {\n            neighbors.push(grid[rowVal - 1][colVal]);\n        }\n        if(rowVal < grid.length - 1) {\n            neighbors.push(grid[rowVal + 1][colVal])\n        }\n        if (colVal > 0) {\n            neighbors.push(grid[rowVal][colVal - 1]);\n        }\n        if(colVal < grid[rowVal].length - 1) {\n            neighbors.push(grid[rowVal][colVal + 1]);\n        }\n        \n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n\n        for(let x = 0; x < neighbors.length; x++) {\n            neighbors[x].setDistance(closestPoint.distance + 1);\n            neighbors[x].setPrevious(closestPoint);\n        }\n        \n    }\n\n    return pointsInOrder;\n}\n\n/**\n * Helper function to return all points in grid, as an array.\n * @param {*} grid whole grid. \n * @returns all points as an array.\n */\nconst getAllPoints = (grid) => {\n    const points = [];\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[i].length; j++) {\n            points.push(grid[i][j]);\n        }\n    }\n\n    return points;\n}\n\n/**\n * Returns shortest path in order between start and end points.\n * @param {*} endPoint end point.\n * @returns shortest path in order.\n */\nexport const shortestPathInOrder = (endPoint) => {\n    const inOrderPath = [];\n    var curr = endPoint;\n    while (curr !== null) {\n        inOrderPath.unshift(curr);\n        curr = curr.previous;\n    }\n\n    return inOrderPath;\n}","import React, {useEffect, useState} from \"react\";\nimport {Point} from './../Objects/Point';\nimport Node from './Node';\nimport {Button, Modal} from 'react-bootstrap';\nimport './../main.css'\nimport {breadthFirstSearch, shortestPathInOrder} from './../algorithms/bfs';\n\nexport default function Grid () {\n\n    const [grid, setGrid] = useState([]);\n    const [numSpecials, setNumSpecials] = useState(0);\n\n    const [show, setShow] = useState(false);\n\n    const handleClose = () => setShow(false);\n    const handleShow = () => setShow(true);\n\n\n    const [showIns, setShowIns] = useState(false);\n    const handleCloseIns = () => setShowIns(false);\n    const handleShowIns = () => setShowIns(true);\n\n    useEffect(() => { \n        handleShowIns();\n\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n\n        console.log(height, width);\n\n        initGrid(height / 28, width / 20);\n\n\n        function handleResize() {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            console.log(height, width);\n\n            initGrid(height / 28, width / 20);\n        }\n\n        window.addEventListener('resize', handleResize);\n    }, [])\n\n    \n    /**\n     * Initializes an empty grid.\n     * \n     * @param {*} rows # of rows\n     * @param {*} cols # of columns.\n     */\n    const initGrid = (rows, cols) => {\n        const tempGrid = [];\n\n        for(let i = 0; i < rows; i++) {\n            const currRow = [];\n            for(let j = 0; j < cols; j++) {\n                currRow.push(new Point(i, j));\n            }   \n\n            tempGrid.push(currRow);\n        }\n\n        setGrid(tempGrid);\n    }\n\n\n    /**\n     * Calls and visualizes the depth first search algorithm.\n     */\n    const generateMaze = () => {\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart || grid[i][j].isEnd) {\n                    continue;\n                }\n                if(grid[i][j].isWall) {\n                    grid[i][j].setWall(false);\n                    document.getElementById(`node-${grid[i][j].x}-${grid[i][j].y}`).className = 'node';\n                }\n            }\n        }\n\n        const walls = []\n\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart || grid[i][j].isEnd) {\n                    continue;\n                }\n                const randInt = getRandomInt(4);\n                if(randInt === 0) {\n                    grid[i][j].setWall(true);\n                    walls.push(grid[i][j]);\n                }\n            }\n        }\n\n        for(let k = 0; k < walls.length; k++) {\n            setTimeout(() => { \n                const currPoint = walls[k];\n                document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-wall';\n            }, 2 * k)\n            \n        }\n\n\n    }\n\n    /**\n     * Helper function to get random integer.\n     * @param {*} max ceiling\n     * @returns random int.\n     */\n    function getRandomInt(max) {\n        return Math.floor(Math.random() * max);\n    }\n\n\n    /**\n     * Calls and visualizes the breadth first search algorithm.\n     */\n    const bfs = () => { \n        var startPoint = null;\n        var endPoint = null;\n\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart) {\n                    startPoint = grid[i][j];\n                }\n                else if(grid[i][j].isEnd) {\n                    endPoint = grid[i][j];\n                }\n            }\n        }\n\n        if(startPoint === null || endPoint === null) {\n            handleShow();\n            return;\n        }\n\n        const pointsInOrder = breadthFirstSearch(startPoint, endPoint, grid);\n       \n        for(let k = 0; k <= pointsInOrder.length; k++) {\n            if (k === pointsInOrder.length) {\n                setTimeout(() => { \n                    const shortestPath = shortestPathInOrder(endPoint);\n                    for(let k = 0; k < shortestPath.length; k++) {\n                        setTimeout(() => { \n                            const currPoint = shortestPath[k];\n                            if (!currPoint.equals(startPoint) && !currPoint.equals(endPoint)) {\n                                document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-path';\n                            }\n                        }, 20 * k)\n                    }\n                }, 2 * k)\n            }\n            else {\n                setTimeout(() => { \n                    const currPoint = pointsInOrder[k];\n                    if (!currPoint.equals(startPoint) && !currPoint.equals(endPoint)) {\n                        document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-visited';\n                    }\n                }, 2 * k)\n            }\n        }\n    }\n    \n    return ( \n        <>\n            <div className=\"container\">\n            <h1 style={{marginBottom: '15px'}} >Pathfinding Visualizer</h1>\n                <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={() => window.location.reload(false)}>Reset</Button>\n                <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={generateMaze}>Generate Maze</Button>\n                <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={bfs}>Breadth First Search</Button>\n            </div>\n            <div>\n                {grid.map((row, rowId) => {\n                    return (\n                        <div key={rowId} className=\"rowContainer\">\n                            {row.map((col, colId) => {\n                                return (\n                                    <Node key={colId} point={grid[rowId][colId]} numSpecials={numSpecials} setNumSpecials={setNumSpecials} />\n                                )\n                            })}\n                        </div>\n                    )\n                    })}\n            </div>\n\n            <Modal show={show} onHide={handleClose}>\n                <Modal.Header closeButton>\n                </Modal.Header>\n                <Modal.Body>Illegal grid state. Please specify a start and end point.</Modal.Body>\n                <Modal.Footer>\n                <Button variant=\"secondary\" onClick={handleClose}>\n                    Close\n                </Button>\n                </Modal.Footer>\n            </Modal>\n\n\n\n            <Modal show={showIns} onHide={handleCloseIns}>\n                <Modal.Header closeButton>\n                    <Modal.Title>Instructions</Modal.Title>\n                </Modal.Header>\n                <Modal.Body>\n                    <li>Click on a node once to make it a start node (green)</li>\n                    <li>Click on a node twice (or once if node is already a start node) to make it an end node (magenta).</li>\n                    <li>Hold 'w' and drag mouse to generate wall nodes, or click on \"Generate Maze\" to create a random maze.</li>\n                    <li>Click \"Reset\" to clear the grid.</li>\n                </Modal.Body>\n                <Modal.Footer>\n                <Button variant=\"secondary\" onClick={handleCloseIns}>\n                    Close\n                </Button>\n                </Modal.Footer>\n            </Modal>\n        </>    \n    )\n}","import './main.css'\nimport Grid from './components/Grid';\n\nfunction App() {\n  return (\n    <Grid />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}