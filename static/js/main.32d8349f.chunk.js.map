{"version":3,"sources":["Objects/Point.js","components/Node.js","algorithms/bfs.js","components/Grid.js","App.js","index.js"],"names":["Point","x","y","this","isStart","isEnd","distance","Infinity","isVisited","previous","isWall","setWall","boolean","setPrevious","point","setStart","setEnd","setDistance","newDistance","setVisited","equals","comparePoint","Node","numSpecials","setNumSpecials","useState","classes","setClasses","addWall","e","key","id","className","onClick","tempClass","onMouseOver","document","addEventListener","onMouseOut","removeEventListener","getAllPoints","grid","points","i","length","j","push","Grid","setGrid","show","setShow","handleClose","useEffect","initGrid","rows","cols","tempGrid","currRow","style","marginBottom","Button","marginRight","window","location","reload","getElementById","max","walls","Math","floor","random","k","setTimeout","currPoint","startPoint","endPoint","pointsInOrder","unvisited","sort","point1","point2","closestPoint","shift","neighbors","rowVal","colVal","filter","neighbor","breadthFirstSearch","shortestPath","inOrderPath","curr","unshift","shortestPathInOrder","map","row","rowId","col","colId","Modal","onHide","Header","closeButton","Body","Footer","variant","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.32d8349f.chunk.js","sourcesContent":["export class Point {\n\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.isStart = false;\n        this.isEnd = false;\n        this.distance = Infinity;\n        this.isVisited = false;\n        this.previous = null;\n        this.isWall = false;\n\n        this.setWall = (boolean) => {\n            this.isWall = boolean;\n        }\n\n        this.setPrevious = (point) => {\n            this.previous = point;\n        }\n\n        this.setStart = (boolean) => {\n            this.isStart = boolean;\n        }\n\n        this.setEnd = (boolean) => {\n            this.isEnd = boolean;\n        }\n\n        this.setDistance = (newDistance) => {\n            this.distance = newDistance;\n        }\n\n        this.setVisited = (boolean) => {\n            this.isVisited = boolean;\n        }\n\n        this.equals = (comparePoint) => {\n            return this.x === comparePoint.x && this.y === comparePoint.y;\n        }\n    }\n\n    \n}","import React, {useState} from \"react\";\nimport \"./../main.css\"\n\nexport default function Node ({point, numSpecials, setNumSpecials}) {\n    const [classes, setClasses] = useState(\"\");\n\n    /**\n     * Sets the start and end points.\n     */\n    const setPoint = () => {\n        if(!point.isStart && !point.isEnd) {\n            if (numSpecials === 2) {\n                return;\n            }\n            setNumSpecials(numSpecials + 1);\n            point.setStart(true);\n        } else if (point.isStart) {\n            point.setStart(false);\n            point.setEnd(true);\n        } else if (point.isEnd) {\n            setNumSpecials(numSpecials - 1);\n            point.setStart(false);\n            point.setEnd(false);\n        }\n\n        var tempClass = \"\";\n        tempClass = point.isStart ? \"node-start\" : point.isEnd ? \"node-end\" : \"\";\n        setClasses(tempClass);\n    }\n\n    /**\n     * Adds a wall point to the grid.\n     */\n    const addWall = (e) => {\n        // console.log(e.key);\n\n        if (e.key === 'w') {\n            if (!point.isStart && !point.isEnd) {\n                point.setWall(true);\n                setClasses(\"node-wall\");\n            }\n        }\n    }\n\n    /**\n     * The two functions below are helper functions for adding walls.\n     */\n    const mouseIn = () => {\n        document.addEventListener(\"keypress\", addWall);\n    }\n\n    const mouseOut = () => {\n        document.removeEventListener(\"keypress\", addWall);\n    }\n\n    return (\n        <div id={`node-${point.x}-${point.y}`} className={`node ${classes}`} onClick={setPoint} onMouseOver={mouseIn} onMouseOut={mouseOut} />\n    )\n}","\n/**\n * Main breadth first search function.\n * \n * @param {*} startPoint starting point.\n * @param {*} endPoint ending point.\n * @param {*} grid whole grid.\n * @returns all visited points part of bfs in order.\n */\nexport const breadthFirstSearch = (startPoint, grid) => {\n    var pointsInOrder = []\n    startPoint.setDistance(0);\n    const unvisited = getAllPoints(grid);\n\n    while(unvisited.length > 0) {\n        unvisited.sort((point1, point2) => point1.distance - point2.distance);\n        const closestPoint = unvisited.shift();\n\n        if (closestPoint.isWall) {\n            continue;\n        }\n\n        if (closestPoint.distance === Infinity) {\n            return pointsInOrder;\n        }\n\n        closestPoint.setVisited(true);\n        pointsInOrder.push(closestPoint);\n        if(closestPoint.isEnd) {\n            return pointsInOrder;\n        }        \n\n        var neighbors = [];\n        const rowVal = closestPoint.x;\n        const colVal = closestPoint.y;\n\n        if(rowVal > 0) {\n            neighbors.push(grid[rowVal - 1][colVal]);\n        }\n        if(rowVal < grid.length - 1) {\n            neighbors.push(grid[rowVal + 1][colVal])\n        }\n        if (colVal > 0) {\n            neighbors.push(grid[rowVal][colVal - 1]);\n        }\n        if(colVal < grid[rowVal].length - 1) {\n            neighbors.push(grid[rowVal][colVal + 1]);\n        }\n        \n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n\n        for(let x = 0; x < neighbors.length; x++) {\n            neighbors[x].setDistance(closestPoint.distance + 1);\n            neighbors[x].setPrevious(closestPoint);\n        }\n        \n    }\n\n    return pointsInOrder;\n}\n\n/**\n * Helper function to return all points in grid, as an array.\n * @param {*} grid whole grid. \n * @returns all points as an array.\n */\nconst getAllPoints = (grid) => {\n    const points = [];\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[i].length; j++) {\n            points.push(grid[i][j]);\n        }\n    }\n\n    return points;\n}\n\n/**\n * Returns shortest path in order between start and end points.\n * @param {*} endPoint end point.\n * @returns shortest path in order.\n */\nexport const shortestPathInOrder = (endPoint) => {\n    const inOrderPath = [];\n    var curr = endPoint;\n    while (curr !== null) {\n        inOrderPath.unshift(curr);\n        curr = curr.previous;\n    }\n\n    return inOrderPath;\n}","import React, {useEffect, useState} from \"react\";\nimport {Point} from './../Objects/Point';\nimport Node from './Node';\nimport {Button, Modal} from 'react-bootstrap';\nimport './../main.css'\nimport {breadthFirstSearch, shortestPathInOrder} from './../algorithms/bfs';\n\nexport default function Grid () {\n\n    const [grid, setGrid] = useState([]);\n    const [numSpecials, setNumSpecials] = useState(0);\n\n    const [show, setShow] = useState(false);\n\n    const handleClose = () => setShow(false);\n    const handleShow = () => setShow(true);\n\n    useEffect(() => { \n        initGrid(30, 80);\n    }, [])\n\n    \n    /**\n     * Initializes an empty grid.\n     * \n     * @param {*} rows # of rows\n     * @param {*} cols # of columns.\n     */\n    const initGrid = (rows, cols) => {\n        const tempGrid = [];\n\n        for(let i = 0; i < rows; i++) {\n            const currRow = [];\n            for(let j = 0; j < cols; j++) {\n                currRow.push(new Point(i, j));\n            }   \n\n            tempGrid.push(currRow);\n        }\n\n        setGrid(tempGrid);\n    }\n\n\n    /**\n     * Calls and visualizes the depth first search algorithm.\n     */\n    const generateMaze = () => {\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart || grid[i][j].isEnd) {\n                    continue;\n                }\n                if(grid[i][j].isWall) {\n                    grid[i][j].setWall(false);\n                    document.getElementById(`node-${grid[i][j].x}-${grid[i][j].y}`).className = 'node';\n                }\n            }\n        }\n\n        const walls = []\n\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart || grid[i][j].isEnd) {\n                    continue;\n                }\n                const randInt = getRandomInt(4);\n                if(randInt === 0) {\n                    grid[i][j].setWall(true);\n                    walls.push(grid[i][j]);\n                }\n            }\n        }\n\n        for(let k = 0; k < walls.length; k++) {\n            setTimeout(() => { \n                const currPoint = walls[k];\n                document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-wall';\n            }, 2 * k)\n            \n        }\n\n\n    }\n\n    /**\n     * Helper function to get random integer.\n     * @param {*} max ceiling\n     * @returns random int.\n     */\n    function getRandomInt(max) {\n        return Math.floor(Math.random() * max);\n    }\n\n\n    /**\n     * Calls and visualizes the breadth first search algorithm.\n     */\n    const bfs = () => { \n        var startPoint = null;\n        var endPoint = null;\n\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart) {\n                    startPoint = grid[i][j];\n                }\n                else if(grid[i][j].isEnd) {\n                    endPoint = grid[i][j];\n                }\n            }\n        }\n\n        if(startPoint === null || endPoint === null) {\n            handleShow();\n            return;\n        }\n\n        const pointsInOrder = breadthFirstSearch(startPoint, grid);\n        for(let k = 0; k <= pointsInOrder.length; k++) {\n            if (k === pointsInOrder.length) {\n                setTimeout(() => { \n                    const shortestPath = shortestPathInOrder(endPoint);\n                    for(let k = 0; k < shortestPath.length; k++) {\n                        setTimeout(() => { \n                            const currPoint = shortestPath[k];\n                            if (!currPoint.equals(startPoint) && !currPoint.equals(endPoint)) {\n                                document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-path';\n                            }\n                        }, 20 * k)\n                    }\n                }, 2 * k)\n            }\n            else {\n                setTimeout(() => { \n                    const currPoint = pointsInOrder[k];\n                    if (!currPoint.equals(startPoint) && !currPoint.equals(endPoint)) {\n                        document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-visited';\n                    }\n                }, 2 * k)\n            }\n        }\n    }\n    \n    return (\n        <div className=\"container\">\n            <h1 style={{marginBottom: '15px'}} >Pathfinding Visualizer</h1>\n            <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={() => window.location.reload(false)}>Reset</Button>\n            <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={generateMaze}>Generate Maze</Button>\n            <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={bfs}>Breadth First Search</Button>\n            \n            <div>\n                {grid.map((row, rowId) => {\n                    return (\n                        <div key={rowId} className=\"rowContainer\">\n                            {row.map((col, colId) => {\n                                return (\n                                    <Node key={colId} point={grid[rowId][colId]} numSpecials={numSpecials} setNumSpecials={setNumSpecials} />\n                                )\n                            })}\n                        </div>\n                    )\n                    })}\n            </div>\n\n            <Modal show={show} onHide={handleClose}>\n                <Modal.Header closeButton>\n                </Modal.Header>\n                <Modal.Body>Illegal grid state. Please specify a start and end point.</Modal.Body>\n                <Modal.Footer>\n                <Button variant=\"secondary\" onClick={handleClose}>\n                    Close\n                </Button>\n                </Modal.Footer>\n            </Modal>\n        </div>    \n    )\n}","import './main.css'\nimport Grid from './components/Grid';\n\nfunction App() {\n  return (\n    <Grid />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}