{"version":3,"sources":["objects/Point.js","components/Node.js","algorithms/bfs.js","components/Grid.js","algorithms/dfs.js","App.js","index.js"],"names":["Point","x","y","this","isStart","isEnd","distance","Infinity","isVisited","previous","isWall","isWeight","setWeight","boolean","setWall","setPrevious","point","setStart","setEnd","setDistance","newDistance","setVisited","equals","comparePoint","Node","numSpecials","setNumSpecials","useState","classes","setClasses","addWall","e","key","id","className","onClick","tempClass","onMouseOver","document","addEventListener","onMouseOut","removeEventListener","getAllPoints","grid","points","i","length","j","push","shortestPathInOrder","endPoint","inOrderPath","curr","unshift","Grid","setGrid","algoText","setAlgoText","speed","setSpeed","show","setShow","handleClose","handleShow","showIns","setShowIns","handleCloseIns","useEffect","width","window","innerWidth","height","innerHeight","initGrid","rows","cols","tempGrid","currRow","Button","style","marginBottom","marginRight","location","reload","getElementById","max","walls","Math","floor","random","k","setTimeout","currPoint","DropdownButton","title","Dropdown","Item","startPoint","pointsInOrder","unvisited","sort","point1","point2","closestPoint","shift","neighbors","rowVal","colVal","filter","neighbor","breadthFirstSearch","shortestPath","stack","pop","depthFirstSearch","Form","Label","Range","onChange","target","value","map","row","rowId","col","colId","Modal","onHide","Header","closeButton","Body","Footer","variant","Title","App","ReactDOM","render","StrictMode"],"mappings":"2NAAaA,EAET,WAAYC,EAAGC,GAAI,IAAD,2BACdC,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,EACTC,KAAKC,SAAU,EACfD,KAAKE,OAAQ,EACbF,KAAKG,SAAWC,IAChBJ,KAAKK,WAAY,EACjBL,KAAKM,SAAW,KAChBN,KAAKO,QAAS,EACdP,KAAKQ,UAAW,EAEhBR,KAAKS,UAAY,SAACC,GACd,EAAKF,SAAWE,GAGpBV,KAAKW,QAAU,SAACD,GACZ,EAAKH,OAASG,GAGlBV,KAAKY,YAAc,SAACC,GAChB,EAAKP,SAAWO,GAGpBb,KAAKc,SAAW,SAACJ,GACb,EAAKT,QAAUS,GAGnBV,KAAKe,OAAS,SAACL,GACX,EAAKR,MAAQQ,GAGjBV,KAAKgB,YAAc,SAACC,GAChB,EAAKd,SAAWc,GAGpBjB,KAAKkB,WAAa,SAACR,GACf,EAAKL,UAAYK,GAGrBV,KAAKmB,OAAS,SAACC,GACX,OAAO,EAAKtB,IAAMsB,EAAatB,GAAK,EAAKC,IAAMqB,EAAarB,I,OCvCzD,SAASsB,EAAT,GAAsD,IAAtCR,EAAqC,EAArCA,MAAOS,EAA8B,EAA9BA,YAAaC,EAAiB,EAAjBA,eAC/C,EAA8BC,mBAAS,IAAvC,mBAAOC,EAAP,KAAgBC,EAAhB,KA+BMC,EAAU,SAACC,GAGC,MAAVA,EAAEC,MACGhB,EAAMZ,SAAYY,EAAMX,QACzBW,EAAMF,SAAQ,GACde,EAAW,gBAgBvB,OACI,qBAAKI,GAAE,eAAUjB,EAAMf,EAAhB,YAAqBe,EAAMd,GAAKgC,UAAS,eAAUN,GAAWO,QAjDxD,WAGb,GAFAnB,EAAMF,SAAQ,GAEVE,EAAMZ,SAAYY,EAAMX,MAMjBW,EAAMZ,SACbY,EAAMC,UAAS,GACfD,EAAME,QAAO,IACNF,EAAMX,QACbqB,EAAeD,EAAc,GAC7BT,EAAMC,UAAS,GACfD,EAAME,QAAO,QAZkB,CAC/B,GAAoB,IAAhBO,EACA,OAEJC,EAAeD,EAAc,GAC7BT,EAAMC,UAAS,GAUnB,IAAImB,EACJA,EAAYpB,EAAMZ,QAAU,aAAeY,EAAMX,MAAQ,WAAa,GACtEwB,EAAWO,IA6B6EC,YAT5E,WACZC,SAASC,iBAAiB,WAAYT,IAQwEU,WALjG,WACbF,SAASG,oBAAoB,WAAYX,M,4CCY3CY,EAAe,SAACC,GAElB,IADA,IAAMC,EAAS,GACPC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAC/BH,EAAOI,KAAKL,EAAKE,GAAGE,IAI5B,OAAOH,GAQEK,EAAsB,SAACC,GAGhC,IAFA,IAAMC,EAAc,GAChBC,EAAOF,EACK,OAATE,GACHD,EAAYE,QAAQD,GACpBA,EAAOA,EAAK3C,SAGhB,OAAO0C,GClFI,SAASG,IAEpB,MAAwB3B,mBAAS,IAAjC,mBAAOgB,EAAP,KAAaY,EAAb,KACA,EAAsC5B,mBAAS,GAA/C,mBAAOF,EAAP,KAAoBC,EAApB,KAEA,EAAgCC,mBAAS,IAAzC,mBAAO6B,EAAP,KAAiBC,EAAjB,KAEA,EAA0B9B,mBAAS,GAAnC,mBAAO+B,EAAP,KAAcC,EAAd,KAEA,EAAwBhC,oBAAS,GAAjC,mBAAOiC,EAAP,KAAaC,EAAb,KAEMC,EAAc,kBAAMD,GAAQ,IAC5BE,EAAa,kBAAMF,GAAQ,IAGjC,EAA8BlC,oBAAS,GAAvC,mBAAOqC,EAAP,KAAgBC,EAAhB,KACMC,EAAiB,kBAAMD,GAAW,IAGxCE,qBAAU,WACN,IAAMC,EAAQC,OAAOC,WACfC,EAASF,OAAOG,YAEtBC,EAASF,EAAS,GAAIH,EAAQ,IAU9BC,OAAO9B,iBAAiB,UAPxB,WACI,IAAM6B,EAAQC,OAAOC,WACfC,EAASF,OAAOG,YAEtBC,EAASF,EAAS,GAAIH,EAAQ,SAInC,IASH,IAAMK,EAAW,SAACC,EAAMC,GAGpB,IAFA,IAAMC,EAAW,GAET/B,EAAI,EAAGA,EAAI6B,EAAM7B,IAAK,CAE1B,IADA,IAAMgC,EAAU,GACR9B,EAAI,EAAGA,EAAI4B,EAAM5B,IACrB8B,EAAQ7B,KAAK,IAAIhD,EAAM6C,EAAGE,IAG9B6B,EAAS5B,KAAK6B,GAGlBtB,EAAQqB,IA4KZ,OACI,qCACI,sBAAK1C,UAAU,YAAf,UAEI,cAAC4C,EAAA,EAAD,CAAQC,MAAO,CAACC,aAAc,OAAQC,YAAa,QAAS9C,QAtNlD,kBAAM8B,GAAW,IAsN3B,+BACA,cAACa,EAAA,EAAD,CAAQC,MAAO,CAACC,aAAc,OAAQC,YAAa,QAAS9C,QAAS,kBAAMkC,OAAOa,SAASC,QAAO,IAAlG,mBACA,cAACL,EAAA,EAAD,CAAQC,MAAO,CAACC,aAAc,OAAQC,YAAa,QAAS9C,QA3KnD,WACjB,IAAI,IAAIU,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAC3BJ,EAAKE,GAAGE,GAAG3C,SAAWuC,EAAKE,GAAGE,GAAG1C,OAGlCsC,EAAKE,GAAGE,GAAGrC,SACViC,EAAKE,GAAGE,GAAGjC,SAAQ,GACnBwB,SAAS8C,eAAT,eAAgCzC,EAAKE,GAAGE,GAAG9C,EAA3C,YAAgD0C,EAAKE,GAAGE,GAAG7C,IAAKgC,UAAY,QAOxF,IAFA,IA+BkBmD,EA/BZC,EAAQ,GAENzC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAAK,CACpC,IAAIJ,EAAKE,GAAGE,GAAG3C,UAAWuC,EAAKE,GAAGE,GAAG1C,MAItB,KAuBLgF,EAxBmB,EAyB9BE,KAAKC,MAAMD,KAAKE,SAAWJ,MAvBtB1C,EAAKE,GAAGE,GAAGjC,SAAQ,GACnBwE,EAAMtC,KAAKL,EAAKE,GAAGE,KAK/B,IA5BuB,eA4Bf2C,GACJC,YAAW,WACP,IAAMC,EAAYN,EAAMI,GACxBpD,SAAS8C,eAAT,eAAgCQ,EAAU3F,EAA1C,YAA+C2F,EAAU1F,IAAKgC,UAAY,mBAC3EwB,EAAQgC,IAJPA,EAAI,EAAGA,EAAIJ,EAAMxC,OAAQ4C,IAAM,EAA/BA,IA+IA,2BACA,eAACG,EAAA,EAAD,CAAgB5D,GAAG,wBAAwB6D,MAAM,mBAAjD,UACA,cAACC,EAAA,EAASC,KAAV,CAAe7D,QAzDf,WAIR,IAHA,IAAI8D,EAAa,KACb/C,EAAW,KAEPL,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAC3BJ,EAAKE,GAAGE,GAAG3C,QACX6F,EAAatD,EAAKE,GAAGE,GAEjBJ,EAAKE,GAAGE,GAAG1C,QACf6C,EAAWP,EAAKE,GAAGE,IAK/B,GAAkB,OAAfkD,GAAoC,OAAb/C,EAA1B,CAKA,IAAMgD,EDrMoB,SAACD,EAAY/C,EAAUP,GACrD,IAAIuD,EAAgB,GACpBD,EAAW9E,YAAY,GAGvB,IAFA,IAAMgF,EAAYzD,EAAaC,GAEzBwD,EAAUrD,OAAS,GAAG,CACxBqD,EAAUC,MAAK,SAACC,EAAQC,GAAT,OAAoBD,EAAO/F,SAAWgG,EAAOhG,YAC5D,IAAMiG,EAAeJ,EAAUK,QAE/B,IAAID,EAAa7F,OAAjB,CAIA,GAAI6F,EAAajG,WAAaC,IAC1B,OAAO2F,EAKX,GAFAK,EAAalF,YAAW,GACxB6E,EAAclD,KAAKuD,GAChBA,EAAajF,OAAO4B,GACnB,OAAOgD,EAGX,IAAIO,EAAY,GACVC,EAASH,EAAatG,EACtB0G,EAASJ,EAAarG,EAEzBwG,EAAS,GACRD,EAAUzD,KAAKL,EAAK+D,EAAS,GAAGC,IAEjCD,EAAS/D,EAAKG,OAAS,GACtB2D,EAAUzD,KAAKL,EAAK+D,EAAS,GAAGC,IAEhCA,EAAS,GACTF,EAAUzD,KAAKL,EAAK+D,GAAQC,EAAS,IAEtCA,EAAShE,EAAK+D,GAAQ5D,OAAS,GAC9B2D,EAAUzD,KAAKL,EAAK+D,GAAQC,EAAS,IAGzCF,EAAYA,EAAUG,QAAO,SAAAC,GAAQ,OAAKA,EAASrG,aAEnD,IAAI,IAAIP,EAAI,EAAGA,EAAIwG,EAAU3D,OAAQ7C,IACjCwG,EAAUxG,GAAGkB,YAAYoF,EAAajG,SAAW,GACjDmG,EAAUxG,GAAGc,YAAYwF,IAKjC,OAAOL,ECoJmBY,CAAmBb,EAAY/C,EAAUP,GAE/Dc,EAAY,sDAEZ,IAxBc,eAwBNiC,GACAA,IAAMQ,EAAcpD,OACpB6C,YAAW,WAEP,IADA,IAAMoB,EAAe9D,EAAoBC,GAD5B,WAELwC,GACJC,YAAW,WACP,IAAMC,EAAYmB,EAAarB,GAC1BE,EAAUtE,OAAO2E,IAAgBL,EAAUtE,OAAO4B,KACnDZ,SAAS8C,eAAT,eAAgCQ,EAAU3F,EAA1C,YAA+C2F,EAAU1F,IAAKgC,UAAY,oBAE/E,GAAKwD,IANJA,EAAI,EAAGA,EAAIqB,EAAajE,OAAQ4C,IAAM,EAAtCA,KAQThC,EAAQgC,GAGXC,YAAW,WACP,IAAMC,EAAYM,EAAcR,GAC3BE,EAAUtE,OAAO2E,IAAgBL,EAAUtE,OAAO4B,KACnDZ,SAAS8C,eAAT,eAAgCQ,EAAU3F,EAA1C,YAA+C2F,EAAU1F,IAAKgC,UAAY,uBAE/EwB,EAAQgC,IApBXA,EAAI,EAAGA,GAAKQ,EAAcpD,OAAQ4C,IAAM,EAAxCA,QARJ3B,KAyCI,kCACA,cAACgC,EAAA,EAASC,KAAV,CAAe7D,QA3Hd,WAIT,IAHA,IAAI8D,EAAa,KACb/C,EAAW,KAEPL,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAC3BJ,EAAKE,GAAGE,GAAG3C,QACX6F,EAAatD,EAAKE,GAAGE,GAEjBJ,EAAKE,GAAGE,GAAG1C,QACf6C,EAAWP,EAAKE,GAAGE,IAK/B,GAAkB,OAAfkD,GAAoC,OAAb/C,EAA1B,CAKA,IAAI,IAAIL,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC5B,IAAI,IAAIE,EAAI,EAAGA,EAAIJ,EAAKE,GAAGC,OAAQC,IAC3BJ,EAAKE,GAAGE,GAAG3C,SAAWuC,EAAKE,GAAGE,GAAG1C,OAGlCsC,EAAKE,GAAGE,GAAGrC,SACViC,EAAKE,GAAGE,GAAGjC,SAAQ,GACnBwB,SAAS8C,eAAT,eAAgCzC,EAAKE,GAAGE,GAAG9C,EAA3C,YAAgD0C,EAAKE,GAAGE,GAAG7C,IAAKgC,UAAY,QAKxF,IAAMgE,EChJkB,SAACD,EAAY/C,EAAUP,GACnD,IAAMuD,EAAgB,GAEhBc,EAAQ,GAId,IAHAf,EAAW9E,YAAY,GACvB6F,EAAMhE,KAAKiD,GAELe,EAAMlE,OAAS,GAAG,CACpB,IAAM8C,EAAYoB,EAAMC,MAExB,GAAGrB,EAAUtE,OAAO4B,GAChB,OAAOgD,EAGX,IAAIN,EAAUpF,UAAW,CACrBoF,EAAUvE,YAAW,GACrB6E,EAAclD,KAAK4C,GACnB,IAAIa,EAAY,GACVC,EAASd,EAAU3F,EACnB0G,EAASf,EAAU1F,EAEtBwG,EAAS,GACRD,EAAUzD,KAAKL,EAAK+D,EAAS,GAAGC,IAEjCD,EAAS/D,EAAKG,OAAS,GACtB2D,EAAUzD,KAAKL,EAAK+D,EAAS,GAAGC,IAEhCA,EAAS,GACTF,EAAUzD,KAAKL,EAAK+D,GAAQC,EAAS,IAEtCA,EAAShE,EAAK+D,GAAQ5D,OAAS,GAC9B2D,EAAUzD,KAAKL,EAAK+D,GAAQC,EAAS,IAGzCF,EAAYA,EAAUG,QAAO,SAAAC,GAAQ,OAAKA,EAASrG,aAEnD,IAAI,IAAIP,EAAI,EAAGA,EAAIwG,EAAU3D,OAAQ7C,IACjCwG,EAAUxG,GAAGkB,YAAYyE,EAAUtF,SAAW,GAC9CmG,EAAUxG,GAAGc,YAAY6E,GACzBoB,EAAMhE,KAAKyD,EAAUxG,MDyGPiH,CAAiBjB,EAAY/C,EAAUP,GAE7Dc,EAAY,4DAGZ,IArCe,eAqCPiC,GACAA,IAAMQ,EAAcpD,OACpB6C,YAAW,WAEP,IADA,IAAMoB,EAAe9D,EAAoBC,GAD5B,WAELwC,GACJC,YAAW,WACP,IAAMC,EAAYmB,EAAarB,GAC1BE,EAAUtE,OAAO2E,IAAgBL,EAAUtE,OAAO4B,KACnDZ,SAAS8C,eAAT,eAAgCQ,EAAU3F,EAA1C,YAA+C2F,EAAU1F,IAAKgC,UAAY,oBAE/E,GAAKwD,IANJA,EAAI,EAAGA,EAAIqB,EAAajE,OAAQ4C,IAAM,EAAtCA,KAQThC,EAAQgC,GAGXC,YAAW,WACP,IAAMC,EAAYM,EAAcR,GAC3BE,EAAUtE,OAAO2E,IAAgBL,EAAUtE,OAAO4B,KACnDZ,SAAS8C,eAAT,eAAgCQ,EAAU3F,EAA1C,YAA+C2F,EAAU1F,IAAKgC,UAAY,uBAE/EwB,EAAQgC,IApBXA,EAAI,EAAGA,GAAKQ,EAAcpD,OAAQ4C,IAAM,EAAxCA,QArBJ3B,KA2GI,oDAEA,uBACA,cAACoD,EAAA,EAAKC,MAAN,wBACA,uBACA,cAACD,EAAA,EAAKE,MAAN,CAAYtC,MAAO,CAACX,MAAOC,OAAOC,WAAa,GAAIgD,SAAU,SAACvF,GAAD,OAAO4B,EAAS,GAAM5B,EAAEwF,OAAOC,MAAQ,OACpG,oBAAIzC,MAAO,CAACC,aAAc,QAA1B,SAAqCxB,OAEzC,8BACKb,EAAK8E,KAAI,SAACC,EAAKC,GACZ,OACI,qBAAiBzF,UAAU,eAA3B,SACKwF,EAAID,KAAI,SAACG,EAAKC,GACX,OACI,cAACrG,EAAD,CAAkBR,MAAO2B,EAAKgF,GAAOE,GAAQpG,YAAaA,EAAaC,eAAgBA,GAA5EmG,OAHbF,QAWtB,eAACG,EAAA,EAAD,CAAOlE,KAAMA,EAAMmE,OAAQjE,EAA3B,UACI,cAACgE,EAAA,EAAME,OAAP,CAAcC,aAAW,IAEzB,cAACH,EAAA,EAAMI,KAAP,wEACA,cAACJ,EAAA,EAAMK,OAAP,UACA,cAACrD,EAAA,EAAD,CAAQsD,QAAQ,YAAYjG,QAAS2B,EAArC,wBAQJ,eAACgE,EAAA,EAAD,CAAOlE,KAAMI,EAAS+D,OAAQ7D,EAA9B,UACI,cAAC4D,EAAA,EAAME,OAAP,CAAcC,aAAW,EAAzB,SACI,cAACH,EAAA,EAAMO,MAAP,6BAEJ,eAACP,EAAA,EAAMI,KAAP,WACI,qFACA,kIACA,wIACA,oHACA,qEAEJ,cAACJ,EAAA,EAAMK,OAAP,UACA,cAACrD,EAAA,EAAD,CAAQsD,QAAQ,YAAYjG,QAAS+B,EAArC,2BE1RDoE,MANf,WACE,OACE,cAAChF,EAAD,K,MCAJiF,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFnG,SAAS8C,eAAe,W","file":"static/js/main.18cf4170.chunk.js","sourcesContent":["export class Point {\n\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.isStart = false;\n        this.isEnd = false;\n        this.distance = Infinity;\n        this.isVisited = false;\n        this.previous = null;\n        this.isWall = false;\n        this.isWeight = false;\n\n        this.setWeight = (boolean) => {\n            this.isWeight = boolean;\n        }\n\n        this.setWall = (boolean) => {\n            this.isWall = boolean;\n        }\n\n        this.setPrevious = (point) => {\n            this.previous = point;\n        }\n\n        this.setStart = (boolean) => {\n            this.isStart = boolean;\n        }\n\n        this.setEnd = (boolean) => {\n            this.isEnd = boolean;\n        }\n\n        this.setDistance = (newDistance) => {\n            this.distance = newDistance;\n        }\n\n        this.setVisited = (boolean) => {\n            this.isVisited = boolean;\n        }\n\n        this.equals = (comparePoint) => {\n            return this.x === comparePoint.x && this.y === comparePoint.y;\n        }\n    }\n\n    \n}","import React, {useState} from \"react\";\nimport \"./../main.css\"\n\nexport default function Node ({point, numSpecials, setNumSpecials}) {\n    const [classes, setClasses] = useState(\"\");\n\n    /**\n     * Sets the start and end points.\n     */\n    const setPoint = () => {\n        point.setWall(false);\n\n        if(!point.isStart && !point.isEnd) {\n            if (numSpecials === 2) {\n                return;\n            }\n            setNumSpecials(numSpecials + 1);\n            point.setStart(true);\n        } else if (point.isStart) {\n            point.setStart(false);\n            point.setEnd(true);\n        } else if (point.isEnd) {\n            setNumSpecials(numSpecials - 1);\n            point.setStart(false);\n            point.setEnd(false);\n        }\n\n        var tempClass = \"\";\n        tempClass = point.isStart ? \"node-start\" : point.isEnd ? \"node-end\" : \"\";\n        setClasses(tempClass);\n    }\n\n    /**\n     * Adds a wall point to the grid.\n     */\n    const addWall = (e) => {\n        // console.log(e.key);\n\n        if (e.key === 'w') {\n            if (!point.isStart && !point.isEnd) {\n                point.setWall(true);\n                setClasses(\"node-wall\");\n            }\n        }\n    }\n\n    /**\n     * The two functions below are helper functions for adding walls.\n     */\n    const mouseIn = () => {\n        document.addEventListener(\"keypress\", addWall);\n    }\n\n    const mouseOut = () => {\n        document.removeEventListener(\"keypress\", addWall);\n    }\n\n    return (\n        <div id={`node-${point.x}-${point.y}`} className={`node ${classes}`} onClick={setPoint} onMouseOver={mouseIn} onMouseOut={mouseOut} />\n    )\n}","\n/**\n * Main breadth first search function.\n * \n * @param {*} startPoint starting point.\n * @param {*} endPoint ending point.\n * @param {*} grid whole grid.\n * @returns all visited points part of bfs in order.\n */\nexport const breadthFirstSearch = (startPoint, endPoint, grid) => {\n    var pointsInOrder = []\n    startPoint.setDistance(0);\n    const unvisited = getAllPoints(grid);\n\n    while(unvisited.length > 0) {\n        unvisited.sort((point1, point2) => point1.distance - point2.distance);\n        const closestPoint = unvisited.shift();\n\n        if (closestPoint.isWall) {\n            continue;\n        }\n\n        if (closestPoint.distance === Infinity) {\n            return pointsInOrder;\n        }\n\n        closestPoint.setVisited(true);\n        pointsInOrder.push(closestPoint);\n        if(closestPoint.equals(endPoint)) {\n            return pointsInOrder;\n        }        \n\n        var neighbors = [];\n        const rowVal = closestPoint.x;\n        const colVal = closestPoint.y;\n\n        if(rowVal > 0) {\n            neighbors.push(grid[rowVal - 1][colVal]);\n        }\n        if(rowVal < grid.length - 1) {\n            neighbors.push(grid[rowVal + 1][colVal])\n        }\n        if (colVal > 0) {\n            neighbors.push(grid[rowVal][colVal - 1]);\n        }\n        if(colVal < grid[rowVal].length - 1) {\n            neighbors.push(grid[rowVal][colVal + 1]);\n        }\n        \n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n\n        for(let x = 0; x < neighbors.length; x++) {\n            neighbors[x].setDistance(closestPoint.distance + 1);\n            neighbors[x].setPrevious(closestPoint);\n        }\n        \n    }\n\n    return pointsInOrder;\n}\n\n/**\n * Helper function to return all points in grid, as an array.\n * @param {*} grid whole grid. \n * @returns all points as an array.\n */\nconst getAllPoints = (grid) => {\n    const points = [];\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[i].length; j++) {\n            points.push(grid[i][j]);\n        }\n    }\n\n    return points;\n}\n\n/**\n * Returns shortest path in order between start and end points.\n * @param {*} endPoint end point.\n * @returns shortest path in order.\n */\nexport const shortestPathInOrder = (endPoint) => {\n    const inOrderPath = [];\n    var curr = endPoint;\n    while (curr !== null) {\n        inOrderPath.unshift(curr);\n        curr = curr.previous;\n    }\n\n    return inOrderPath;\n}","import React, {useEffect, useState} from \"react\";\nimport {Point} from './../objects/Point';\nimport Node from './Node';\nimport {Button, Modal, Form, Dropdown, DropdownButton} from 'react-bootstrap';\nimport './../main.css'\nimport {breadthFirstSearch, shortestPathInOrder} from './../algorithms/bfs';\nimport {depthFirstSearch} from './../algorithms/dfs';\n\nexport default function Grid () {\n\n    const [grid, setGrid] = useState([]);\n    const [numSpecials, setNumSpecials] = useState(0);\n\n    const [algoText, setAlgoText] = useState(\"\");\n\n    const [speed, setSpeed] = useState(5);\n\n    const [show, setShow] = useState(false);\n\n    const handleClose = () => setShow(false);\n    const handleShow = () => setShow(true);\n\n\n    const [showIns, setShowIns] = useState(false);\n    const handleCloseIns = () => setShowIns(false);\n    const handleShowIns = () => setShowIns(true);\n\n    useEffect(() => { \n        const width = window.innerWidth;\n        const height = window.innerHeight;\n\n        initGrid(height / 32, width / 20);\n\n\n        function handleResize() {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            initGrid(height / 28, width / 20);\n        }\n\n        window.addEventListener('resize', handleResize);\n    }, [])\n\n    \n    /**\n     * Initializes an empty grid.\n     * \n     * @param {*} rows # of rows\n     * @param {*} cols # of columns.\n     */\n    const initGrid = (rows, cols) => {\n        const tempGrid = [];\n\n        for(let i = 0; i < rows; i++) {\n            const currRow = [];\n            for(let j = 0; j < cols; j++) {\n                currRow.push(new Point(i, j));\n            }   \n\n            tempGrid.push(currRow);\n        }\n\n        setGrid(tempGrid);\n    }\n\n\n    /**\n     * Calls and visualizes the depth first search algorithm.\n     */\n    const generateMaze = () => {\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart || grid[i][j].isEnd) {\n                    continue;\n                }\n                if(grid[i][j].isWall) {\n                    grid[i][j].setWall(false);\n                    document.getElementById(`node-${grid[i][j].x}-${grid[i][j].y}`).className = 'node';\n                }\n            }\n        }\n\n        const walls = []\n\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart || grid[i][j].isEnd) {\n                    continue;\n                }\n                const randInt = getRandomInt(4);\n                if(randInt === 0) {\n                    grid[i][j].setWall(true);\n                    walls.push(grid[i][j]);\n                }\n            }\n        }\n\n        for(let k = 0; k < walls.length; k++) {\n            setTimeout(() => { \n                const currPoint = walls[k];\n                document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-wall';\n            }, speed * k)\n            \n        }\n\n\n    }\n\n    /**\n     * Helper function to get random integer.\n     * @param {*} max ceiling\n     * @returns random int.\n     */\n    function getRandomInt(max) {\n        return Math.floor(Math.random() * max);\n    }\n\n    /**\n     * Calls and visualizes the depth first search algorithm.\n     */\n     const dfs = () => { \n        var startPoint = null;\n        var endPoint = null;\n\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart) {\n                    startPoint = grid[i][j];\n                }\n                else if(grid[i][j].isEnd) {\n                    endPoint = grid[i][j];\n                }\n            }\n        }\n\n        if(startPoint === null || endPoint === null) {\n            handleShow();\n            return;\n        }\n\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart || grid[i][j].isEnd) {\n                    continue;\n                }\n                if(grid[i][j].isWall) {\n                    grid[i][j].setWall(false);\n                    document.getElementById(`node-${grid[i][j].x}-${grid[i][j].y}`).className = 'node';\n                }\n            }\n        }\n\n        const pointsInOrder = depthFirstSearch(startPoint, endPoint, grid);\n\n        setAlgoText(\"Depth First Search does not guarantee the shortest path.\")\n\n\n        for(let k = 0; k <= pointsInOrder.length; k++) {\n            if (k === pointsInOrder.length) {\n                setTimeout(() => { \n                    const shortestPath = shortestPathInOrder(endPoint);\n                    for(let k = 0; k < shortestPath.length; k++) {\n                        setTimeout(() => { \n                            const currPoint = shortestPath[k];\n                            if (!currPoint.equals(startPoint) && !currPoint.equals(endPoint)) {\n                                document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-path';\n                            }\n                        }, 20 * k)\n                    }\n                }, speed * k)\n            }\n            else {\n                setTimeout(() => { \n                    const currPoint = pointsInOrder[k];\n                    if (!currPoint.equals(startPoint) && !currPoint.equals(endPoint)) {\n                        document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-visited';\n                    }\n                }, speed * k)\n            }\n        }\n    }\n\n    /**\n     * Calls and visualizes the breadth first search algorithm.\n     */\n    const bfs = () => { \n        var startPoint = null;\n        var endPoint = null;\n\n        for(let i = 0; i < grid.length; i++) {\n            for(let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j].isStart) {\n                    startPoint = grid[i][j];\n                }\n                else if(grid[i][j].isEnd) {\n                    endPoint = grid[i][j];\n                }\n            }\n        }\n\n        if(startPoint === null || endPoint === null) {\n            handleShow();\n            return;\n        }\n\n        const pointsInOrder = breadthFirstSearch(startPoint, endPoint, grid);\n\n        setAlgoText(\"Breadth First Search guarantees the shortest path!\")\n       \n        for(let k = 0; k <= pointsInOrder.length; k++) {\n            if (k === pointsInOrder.length) {\n                setTimeout(() => { \n                    const shortestPath = shortestPathInOrder(endPoint);\n                    for(let k = 0; k < shortestPath.length; k++) {\n                        setTimeout(() => { \n                            const currPoint = shortestPath[k];\n                            if (!currPoint.equals(startPoint) && !currPoint.equals(endPoint)) {\n                                document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-path';\n                            }\n                        }, 20 * k)\n                    }\n                }, speed * k)\n            }\n            else {\n                setTimeout(() => { \n                    const currPoint = pointsInOrder[k];\n                    if (!currPoint.equals(startPoint) && !currPoint.equals(endPoint)) {\n                        document.getElementById(`node-${currPoint.x}-${currPoint.y}`).className = 'node node-visited';\n                    }\n                }, speed * k)\n            }\n        }\n    }\n    \n    return ( \n        <>\n            <div className=\"container\">\n            \n                <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={handleShowIns}>View Instructions</Button>\n                <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={() => window.location.reload(false)}>Reset</Button>\n                <Button style={{marginBottom: '15px', marginRight: '10px'}} onClick={generateMaze}>Generate Maze</Button>\n                <DropdownButton id=\"dropdown-basic-button\" title=\"Select Algorithm\">\n                <Dropdown.Item onClick={bfs}>Breadth First Search</Dropdown.Item>\n                <Dropdown.Item onClick={dfs}>Depth First Search (Walls Disabled)</Dropdown.Item>\n                </DropdownButton>\n                <br/>\n                <Form.Label>Set Speed</Form.Label>\n                <br/>\n                <Form.Range style={{width: window.innerWidth / 3}} onChange={(e) => setSpeed(10 - (e.target.value / 10))} />\n                <h5 style={{marginBottom: '15px'}} >{algoText}</h5>\n            </div>\n            <div>\n                {grid.map((row, rowId) => {\n                    return (\n                        <div key={rowId} className=\"rowContainer\">\n                            {row.map((col, colId) => {\n                                return (\n                                    <Node key={colId} point={grid[rowId][colId]} numSpecials={numSpecials} setNumSpecials={setNumSpecials} />\n                                )\n                            })}\n                        </div>\n                    )\n                    })}\n            </div>\n\n            <Modal show={show} onHide={handleClose}>\n                <Modal.Header closeButton>\n                </Modal.Header>\n                <Modal.Body>Illegal grid state. Please specify a start and end point.</Modal.Body>\n                <Modal.Footer>\n                <Button variant=\"secondary\" onClick={handleClose}>\n                    Close\n                </Button>\n                </Modal.Footer>\n            </Modal>\n\n\n\n            <Modal show={showIns} onHide={handleCloseIns}>\n                <Modal.Header closeButton>\n                    <Modal.Title>Instructions</Modal.Title>\n                </Modal.Header>\n                <Modal.Body>\n                    <li>Click on a node once to make it a start node (star)</li>\n                    <li>Click on a node twice (or once if node is already a start node) to make it an end node (target).</li>\n                    <li>Hold 'w' and drag mouse to generate wall nodes, or click on \"Generate Maze\" to create a random maze.</li>\n                    <li>Select an algorithm from the drop down menu after specifying a start and end node.</li>\n                    <li>Click \"Reset\" to clear the grid.</li>\n                </Modal.Body>\n                <Modal.Footer>\n                <Button variant=\"secondary\" onClick={handleCloseIns}>\n                    Close\n                </Button>\n                </Modal.Footer>\n            </Modal>\n        </>    \n    )\n}","\n/**\n * Main depth first search function.\n * \n * @param {*} startPoint starting point.\n * @param {*} endPoint ending point.\n * @param {*} grid whole grid.\n * @returns all visited points part of bfs in order.\n */\nexport const depthFirstSearch = (startPoint, endPoint, grid) => {\n    const pointsInOrder = [];\n\n    const stack = [];\n    startPoint.setDistance(0);\n    stack.push(startPoint);\n\n    while(stack.length > 0) {\n        const currPoint = stack.pop();\n\n        if(currPoint.equals(endPoint)) {\n            return pointsInOrder;\n        }\n\n        if(!currPoint.isVisited) {\n            currPoint.setVisited(true);\n            pointsInOrder.push(currPoint);\n            var neighbors = [];\n            const rowVal = currPoint.x;\n            const colVal = currPoint.y;\n\n            if(rowVal > 0) {\n                neighbors.push(grid[rowVal - 1][colVal]);\n            }\n            if(rowVal < grid.length - 1) {\n                neighbors.push(grid[rowVal + 1][colVal])\n            }\n            if (colVal > 0) {\n                neighbors.push(grid[rowVal][colVal - 1]);\n            }\n            if(colVal < grid[rowVal].length - 1) {\n                neighbors.push(grid[rowVal][colVal + 1]);\n            }\n\n            neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n\n            for(let x = 0; x < neighbors.length; x++) {\n                neighbors[x].setDistance(currPoint.distance + 1);\n                neighbors[x].setPrevious(currPoint);\n                stack.push(neighbors[x]);\n            }\n        }\n    }\n}","import './main.css'\nimport Grid from './components/Grid';\n\nfunction App() {\n  return (\n    <Grid />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}